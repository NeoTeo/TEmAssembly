^10 @console/vector
^12 @console/read
^18 @console/write

^28 @screen/xposition
^2A @screen/yposition
^2E @screen/color

^42 @scratch

^50 @char/4
00 00 08 18 28 3C 08 00
^58 @char/2
00 00 38 04 18 20 3C 00 

^80 @hejverden 48 65 6A 20 76 65 72 64 65 6E 0D

^100

( a character is 8 x 8 bits )
@main
	#@convec _@console/vector bsoS ( set the console interrupt vector ) 
	( #2 #0005 #0010 #@char/4 $@charline jsr )
	( #2 #0005 #0011 #@char/2 $@charline jsr ) 
	( $@console jsr )
	brk

( console input interrupt handler )
@convec
	#2 #0010 #0020 
	_@console/read bsi 
	$@fontoffset jsr #@font/monomini addS
	$@charline jsr
	
jmpSR

@fontoffset ( ascii -- offset )
	#0 swp	( turn byte into short )
	#30 shiS		
jmpSR

@console
	#0 
	@console_loop
		dup #@hejverden rot add lda	
		dup #0 equ $@console_done jnz 
		_@console/write bso
		#1 add
		$@console_loop jmp 
	@console_done
jmpSR


@colrowtoxy ( colS row -- x y ) ( all shorts )
	( screen resolution is 640x480. Each cell in grid is 8x8. So x is 8*col and y is 8*row )
	#30 shiS swpS
	#30 shiS
	jmpSR

@charline ( cidx row col addr -- ) ( b s s s )
	stsS 				( addr to rstack )  
	#0 sts				( y counter to rstack )
	$@colrowtoxy jsr	( convert row and col to xy ) 
	@cl_yloop			( y coords loop )
		#0 stsRC rotR rotR stsSRC rotR 
		addS
		lda				( load byte at data address )
		#80 			( start from msbit ) 
		@cl_xloop
			stsSC 					( copy byte data and mask to rstack )
			and	#0 equ 				( check for pixel )
			$@cl_xloop_skip jnz		( skip if no pixel )	
			$@dup5 jsr
			$@dot jsr
			@cl_xloop_skip
			swpS #01 add swpS		( swap x and y, increment x, swap back again ) 
			stsSR 					( move byte data and mask back from rstack )
			#01 shi					( shift mask bit down one )	
			dup #0 grt 
			$@cl_xloop jnz			( repeat as long as the mask is not zero )
		popS			( drop unused byte data and mask for this scanline ) 
		#1 add 
		swpS
		#8 sub
		swpS
		stsR		( get y count from rstack )
		#1 add stsC		( increment y count and copy to rstack )
		#8 lst $@cl_yloop jnz	
		( stsSR #1 add stsS )	( increment addr ) 
		( dup #8 and #0 equ $@cl_yloop jnz ) 	( fix this: it's not always on 8! )
		popRS popR	( pop the addr off the return stack )
jmpSR

( p: 2 0 2 0 0 40 20 ) ( r: 0 50 )

( this is a code smell that i'm juggling too many parms. Refactor! ) 
@dup5 ( abcde -- abcdeabcde )
	#5 $@pick jsr
	#5 $@pick jsr
	#5 $@pick jsr
	#5 $@pick jsr
	#5 $@pick jsr
	
jmpSR

( picks the value at the given position in the stack and leaves it on top of the stack )
@pick ( n -- n )
	stsC
	@pick_wind
		dup #0 equ $@pick_unwind jnz
		#1 sub swp sts swpR $@pick_wind jmp

	@pick_unwind
		pop ovrR swpR stsSR #1 sub 
		@pick_unwind_unw
			dup #0 equ $@pick_end jnz
			#1 sub swpR stsR swp $@pick_unwind_unw jmp

	@pick_end
	pop
	stsR
jmpSR

@dot ( col x y -- )
	_@screen/yposition bsoS
	_@screen/xposition bsoS 
	_@screen/color bso	 
jmpSR

^400 @font/monomini
( unprintable ascii from 0x400 to 0x41F )
^500 
00 00 00 00 00 00 00 00 ( space )
^590 (0x400 + ascii*8 )
00 00 38 04 18 20 3C 00 ( 2 )
^5A0
00 00 08 18 28 3C 08 00	( 4 )
