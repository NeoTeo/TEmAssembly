^10 @console/vector
^12 @console/read
^18 @console/write

^28 @screen/xposition
^2A @screen/yposition
^2C @screen/addr
^2E @screen/clut
^2F @screen/dma

^90 @mouse/vector &2 @mouse/x &2 @mouse/y &2 @mouse/bstate

^B0 @IME 01 ( enable interrupts )

^C0 @keybufptr 0  ( always points to an available position )
^C1 @keybuf_count 0
^C2 @keybuf_max 20 
^C3 @keybuf ( keybuf_max * byte keyboard buffer )

^E3 @cposbuf_offset 0	( always points to an available position )
^E4 @cposbuf_count 0
^E5 @cposbuf_max 20
^E6 @cposbuf ( each cursor position is 4 bytes; xS yS, so its size is cposbuf_max * 4 )

( macro definitions )
%>= { lst #0 equ } 

( a less-than that interprets values as signed )
%<?S { subS #8000 andS #8000 equS }

( useful for turning two bytes into two shorts if c and d are 0 )
%prezip { swp swpS rot rot swpS } ( a b c d -- c a d b )

%2dupS { ovrS ovrS } ( aS bS -- aS bS aS bS ) 

%setpixel { _@screen/yposition bsoS _@screen/xposition bsoS _@screen/clut bso } ( col xS yS -- )

%fontoffset { #0 swp ( turn byte into short ) #30 shiS }


( convert row and col to xy ) 
( screen resolution is 640x480. Each cell in grid is 8x8. So x is 8*col and y is 8*row )
%rowcoltoxy { #0 #0 prezip #30 shiS swpS  #30 shiS } ( col row -- x y ) ( bb -- ss )

( start of executable code )
^100 

( a character is 8 x 8 bits )
@main
	#@convec _@console/vector bsoS ( set the console interrupt vector ) 
	#@mousevec _@mouse/vector bsoS ( set the mouse interrupt vector ) 
	#0000	( row and col inited )
	( infinite loop )
	@main_toploop

( TODO check for mouse events in the mouse buffer and move the pointer accordingly )

		( check the keybuf_count being > 0 )
		#@keybuf_count lda #0 equ #@main_skip_keybuf jnzS
		
		dupS ( keep copy of row and col before calling drawchar )
		#@pop_keybuf jsrS

		( check for delete and control characters )
		dup #7F equ $@main_doctrl jnz
		dup #20 lst $@main_doctrl jnz

		#@drawchar jsrS 
		
		( increment the columns and rows as characters are printed. )
		#1 #@advancecursor jsrS

		#@main_skip_keybuf jmpS

		( handle control characters )
		@main_doctrl
		dup #7F neq $@main_skip_delete jnz
		pop ( remove extra unneeded char copy )
		( move back and draw a space )	
		#FF #@advancecursor jsrS
		dupS #20 #@drawchar jsrS 
		$@main_skip_keybuf jmp

		@main_skip_delete
		
		dup #0D neq $@main_skip_enter jnz
		pop ( remove extra unneeded char copy )
		( set col to end and advance, which causes it to move to the next line. )
		pop #4F 
		#1 $@advancecursor jsr
		$@main_skip_keybuf jmp

		@main_skip_enter

		#1B neq $@main_skip_esc jnz
		popS popS
		#@dugo jsrS
		@main_skip_esc 

		@main_skip_keybuf

	#@main_toploop jmpS
	brk

@advancecursor ( row col stepval -- newrow newcol )
	sts #50 swp stsCR $@step jsr 
	#0 equ $@advancecursor_skip_vstep jnz 
	swp #3C swp stsCR $@step jsr pop swp
	@advancecursor_skip_vstep
	popR
jmpSR

( step cursor by stepval signed and leave new col and 0xff if the column was reset )
@step ( maxcols col stepval -- newcol didreset )
	add dupS swp lst $@step_norm jnz
	dupS equ $@step_over jnz
	swp #1 sub swp $@step_end jmp ( understepped )
	@step_over popS #0 #FF $@step_end jmp
	@step_norm swp	pop #0
	@step_end
jmpSR

( leave smallest of the two values on stack )
@minS ( aS bS -- rS )
	2dupS <?S $@minS_skipswap jnz
	swpS
	@minS_skipswap 
	popS
jmpSR

@maxS ( aS bS -- rS )
	2dupS <?S #0 equ $@maxS_skipswap jnz
	swpS
	@maxS_skipswap 
	popS
jmpSR

@drawpointer ( xposS yposS -- )
	swpS
	#0000 #@maxS jsrS
	swpS
	#0000 #@maxS jsrS

	#@pointer/x ldaS
	#@pointer/y ldaS

	_@screen/yposition bsoS
	_@screen/xposition bsoS
	#@pointer/clear
	_@screen/addr bsoS			( set dma address )
	#41 _@screen/dma bso		( start dma transfer of 64 bits to fg: bit 1, to foreground layer: bit 7 )

	2dupS 	( duplicate the new position )
	#@pointer/y staS
	#@pointer/x staS

	_@screen/yposition bsoS
	_@screen/xposition bsoS
	 #@pointer/xhair 
	_@screen/addr bsoS			( set dma address )
	#41 _@screen/dma bso		( start dma transfer of 64 bits to fg: bit 1, to foreground layer: bit 7 )
jmpSR

@drawchar ( row col char -- )
	rot rot
	rowcoltoxy
	_@screen/yposition bsoS
	_@screen/xposition bsoS

	fontoffset #@font/monomini addS
	_@screen/addr bsoS

	#1 _@screen/dma bso		( start dma transfer of 64 bits from addr )
jmpSR

( mouse input interrupt handler )
( should just put mouse events into buffer )
@mousevec

(	_@mouse/x bsiS _@mouse/y bsiS #@push_cposbuf jsrS )

	_@mouse/x bsiS #0003 subS
	_@mouse/y bsiS #0003 subS
	#@drawpointer jsrS

	_@mouse/bstate bsi dup #00 equ $@mousevec_skipdraw jnz
	#2 swp #10 equ $@mousevec_defaultc jnz
	pop #0 
	@mousevec_defaultc

	_@mouse/x bsiS
	_@mouse/y bsiS
	setpixel
	$@mousevec_done jmp
	@mousevec_skipdraw

	pop 
	@mousevec_done

	#1 #@IME sta (re-enable interrupts )
jmpSR

@pointer_draw ( xS yS -- )
	stsSC swpS stsSC	( copy yS and xS to rStack )	
	#0003 subS swpS 
	#0003 subS 
	#@drawpointer jsrS

	( only draw when a mouse button is down )
	_@mouse/bstate bsi dup #00 equ $@pointer_draw_skipdraw jnz
	( default color is #2 )
	#2 swp #10 equ $@pointer_draw_defaultc jnz
	pop #0 
	@pointer_draw_defaultc

	( retrieve xS and yS from rStack )
	stsSR stsSR
	setpixel
	$@pointer_draw_done jmp
	@pointer_draw_skipdraw

	pop ( remove unused bstate duplicate )
	@pointer_draw_done
jmpSR

( console input interrupt handler )
@convec
	_@console/read bsi	
	
	#@push_keybuf jsrS
	#1 #@IME sta (re-enable interrupts )
jmpSR

( byte only, range is 0 to max-1 )
@inc_ring ( cur max -- )
	swp #1 add dup rot lst $@inc_ring_skip jnz
	pop #0
	@inc_ring_skip	
jmpSR

@dec_ring ( cur max -- )
	swp #1 sub dupS grt $@dec_ring_skip jnz
	swp #1 sub		
	@dec_ring_skip	
	swp pop
jmpSR

@push_cposbuf ( xS yS -- )
	#@cposbuf #@cposbuf_offset lda stsC			( load the cposbuf_offset and copy to rStack )
	#20 shi add	swpS ovrS staS					( offset cposbuf by cposbuf_offset * 4 to account for two shorts per entry )
	#2 add staS									( store two shorts in buffer at calculated position )
	( empty pStack )
	#@cposbuf_max lda stsR ovr #@inc_ring jsrS	( get offset from rStack and calculate next offset )
	#@cposbuf_offset sta						( store the new offset )

	( increment counter if less than max )
	#@cposbuf_count lda dup rot
	>= $@push_cposbuf_skip jnz					( increment counter if count is less than max ) 
	#1 add
	#@cposbuf_count sta	
	@push_cposbuf_skip
	
jmpSR

@pop_cposbuf ( -- xS yS )
	( just return if the buffer is empty )
	#@cposbuf_count lda dup #0 equ $@pop_cposbuf_skip jnz
	( reduce count and store it )
	#1 sub #@cposbuf_count sta

	#@cposbuf
	#@cposbuf_offset lda #@cposbuf_max lda #@dec_ring jsrS
	dup #@cposbuf_offset sta				( store the new offset )
	#20 shi add dupS ldaS swpS					( add offset * 4 to buffer address to account for 2 short per entry to load yS )
	#2 add ldaS 								( load xS )
	jmpSR									( return )	
	@pop_cposbuf_skip
	pop										( drop unused count duplicate )
jmpSR

@push_keybuf ( val -- )

	#@keybuf #@keybufptr lda stsC ( load the keybuf pointer value and copy to rStack )
	add ( offset keybuf by pointer )
	sta ( store key in keybuf )

	stsR #@keybuf_max lda #@inc_ring jsrS

	#@keybufptr sta ( store the incremented pointer )

	( circular buffer maxes out at #20 )
	#@keybuf_count lda 
	#@keybuf_max lda >= $@push_keybuf_skip jnz
	#@keybuf_count lda #1 add 
	#@keybuf_count sta
	@push_keybuf_skip
jmpSR

@pop_keybuf ( -- char )
	#@keybuf_count lda dup #0 equ $@pop_keybuf_skip jnz 
	#1 sub #@keybuf_count sta

	#@keybuf 
	( keybufptr points to the next free pos so decrement first )
	#@keybufptr lda #@keybuf_max lda #@dec_ring jsrS
	dup #@keybufptr sta 			( store the pointer )
	add 							( offset keybuf by pointer )
	lda								( load the value at the offset onto pStack ) 
	jmpSR
	@pop_keybuf_skip
	pop
jmpSR

@dugo ( -- )
	( #0005 #0003 #027F #01dF #02 #@line jsrS )
	#0042 #0069 #@push_cposbuf jsrS
	#@pop_cposbuf jsrS
jmpSR

( always subtract the smaller from the bigger )
@deltax ( x0S x1S -- dxS )
	2dupS swpS lstS $@deltax_skipswap jnz
	swpS
	@deltax_skipswap
	subS
jmpSR

@deltay ( y0S y1S -- dyS )
	( 2dupS lstS $@deltax_skipswap jnz )
	swpS 2dupS lstS $@deltax_skipswap jnz
	swpS
	@deltax_skipswap
	subS
jmpSR

( Bresenham line drawing algorithm )
@line ( x0S y0S x1S y1S c -- ) 
	( move pixel color to local variable )
	#@line_col sta

	( copy source and destination coords to local variables )
	#@line_y1 staS #@line_x1 staS #@line_y0 staS #@line_x0 staS	

	#@line_x0 ldaS #@line_x1 ldaS 

	( sx = x0 < x1 ? 1 : -1 )
	2dupS lstS #0001 rot $@line_sx_lst jnz
	popS #FFFF
	@line_sx_lst
	#@line_sx staS

	( calculate delta x )
	$@deltax jsr

	( load y0 and y1 )
	#@line_y0 ldaS #@line_y1 ldaS 

	( sy = y0 < y1 ? 1 : -1 )
	2dupS lstS #0001 rot $@line_sy_lst jnz
	popS #FFFF
	@line_sy_lst

	#@line_sy staS

	( calculate delta y )
	$@deltay jsr

	( calculate err )
	2dupS addS 
	swpS  
	#@line_dy staS	
	swpS
	#@line_dx staS	

	$@line_col ldr $@line_x0 ldrS $@line_y0 ldrS
	stsSC stsSC 	( copy y and x to rStack )
	@line_loop
		setpixel	
		( split into two so we only check second part if x == x1. )
		stsSRC $@line_x1 ldrS equS ovrSR
		( stsSRC ) stsSR $@line_y1 ldrS equS and $@line_end jnz
		dupS #0002 mulS ( err2 )
		( if err2 >= dy then increment )
		$@line_dy ldrS 2dupS <?S $@line_yskip jnz
		rotS addS ( err += dy )	

		stsSR $@line_sx ldrS addS		( x += sx )	
		stsS ( put x back on rStack for next iter )
		$@line_ystep jmp
		@line_yskip popS	( pop unused dy )
		@line_ystep

		swpS $@line_dx ldrS dupS ( dup too many when skipping ? ) 
		rotS <?S $@line_xskip jnz 	( if dx < err2 skip y increment )
		addS ( err += dx )
		swpSR stsSR #@line_sy ldaS addS		( y += sy )
		stsS ( put y back on rStack for next iter )
		$@line_loopend jmp
		@line_xskip popS swpSR	( pop unused dx )

		@line_loopend
		$@line_col ldr swpSR stsSRC stsSRC 

		$@line_loop jmp

	@line_end
	popS		( remove the errS )
	popSR popSR ( remove x and y from rStack )
jmpSR

( variables )
@line_col &1 @line_x0 &2 @line_y0 &2 @line_y1 &2 @line_x1 &2
@line_dx &2 @line_dy &2 @line_sx &2 @line_sy 

^500 @pointer/xhair
10 10 00 D6 00 10 10 00
^508 @pointer/clear
00 00 00 00 00 00 00 00
^510 @pointer/x 00 00 @pointer/y 00 00 

(chars are at 0x500 + ascii*8 )
^600 @font/monomini
( unprintable ascii from 0x500 to 0x51F )
^700 
00 00 00 00 00 00 00 00 ( space )
00 10 10 10 00 10 00 00 ( ! )
00 12 24 00 00 00 00 00 ( " )
00 28 7C 28 7C 28 00 00 ( # )
00 08 1C 30 0C 38 08 00 ( $ )
00 48 08 10 20 24 00 00 ( % )
00 30 40 34 48 34 00 00 ( & )
00 20 20 00 00 00 00 00 ( ' )
00 10 20 20 20 10 00 00 ( open parens )
00 20 10 10 10 20 00 00 ( close parens )
00 00 28 10 28 00 00 00 ( * )
00 00 10 38 10 00 00 00 ( + )
00 00 00 00 00 10 20 00 ( , )
00 00 00 38 00 00 00 00 ( - )
00 00 00 00 00 10 00 00 ( . )
00 02 04 08 10 20 00 00 ( / )
00 18 24 24 24 18 00 00 ( 0 )
00 18 08 08 08 08 00 00 ( 1 )
00 38 04 18 20 3C 00 00 ( 2 )
00 38 04 18 04 38 00 00 ( 3 )
00 08 18 28 3C 08 00 00 ( 4 )
00 3C 20 38 04 38 00 00 ( 5 )
00 18 20 38 24 18 00 00 ( 6 )
00 3C 04 08 10 10 00 00 ( 7 )
00 18 24 18 24 18 00 00 ( 8 )
00 18 24 1C 04 18 00 00 ( 9 )
00 00 00 10 00 10 00 00 ( : )
00 00 00 10 00 10 20 00 ( ; )
00 08 10 20 10 08 00 00 ( < )
00 00 38 00 38 00 00 00 ( = )
00 20 10 08 10 20 00 00 ( > )
00 38 04 38 00 20 00 00 ( ? )
00 38 44 5C 54 38 00 00 ( @ )
00 18 24 24 3C 24 00 00 ( A )
00 38 24 38 24 38 00 00 ( B )
00 18 20 20 20 18 00 00 ( C )
00 38 24 24 24 38 00 00 ( D )
00 38 20 38 20 38 00 00 ( E )
00 38 20 38 20 20 00 00 ( F )
00 1C 20 2C 24 1C 00 00 ( G )
00 24 24 3C 24 24 00 00 ( H )
00 38 10 10 10 38 00 00 ( I )
00 0C 04 04 24 18 00 00 ( J )
00 24 28 30 28 24 00 00 ( K )
00 20 20 20 20 38 00 00 ( L )
00 22 36 2A 22 22 00 00 ( M )
00 24 34 2C 24 24 00 00 ( N )
00 18 24 24 24 18 00 00 ( O )
00 38 24 24 38 20 00 00 ( P )
00 18 24 24 28 14 00 00 ( Q )
00 3C 24 24 38 24 00 00 ( R )
00 1C 20 18 04 38 00 00 ( S )
00 38 10 10 10 10 00 00 ( T )
00 24 24 24 24 18 00 00 ( U )
00 24 24 24 28 30 00 00 ( V )
00 44 54 54 54 28 00 00 ( W )
00 24 24 18 24 24 00 00 ( X )
00 24 24 3C 04 18 00 00 ( Y )
00 3C 04 18 20 3C 00 00 ( Z )
00 30 20 20 20 30 00 00 ( [ )
00 20 10 08 04 02 00 00 ( \ )
00 30 10 10 10 30 00 00 ( ] )
00 10 28 00 00 00 00 00 ( ^ )
00 00 00 00 00 3C 00 00 ( _ )
00 20 10 00 00 00 00 00 ( ` )
00 00 1C 24 24 1C 00 00 ( a )
00 20 38 24 24 38 00 00 ( b )
00 00 18 20 20 18 00 00 ( c )
00 04 1C 24 24 1C 00 00 ( d )
00 00 18 2C 30 18 00 00 ( e )
00 08 10 38 10 10 00 00 ( f )
00 00 1C 24 24 1C 04 18 ( g )
00 20 20 30 28 28 00 00 ( h )
00 10 00 10 10 10 00 00 ( i )
00 10 00 10 10 10 20 00 ( j )
00 20 20 28 30 28 00 00 ( k )
00 10 10 10 10 08 00 00 ( l )
00 00 3C 2A 2A 2A 00 00 ( m )
00 00 38 24 24 24 00 00 ( n )
00 00 18 24 24 18 00 00 ( o )
00 00 38 24 24 38 20 20 ( p )
00 00 1C 24 24 1C 04 04 ( q )
00 00 28 30 20 20 00 00 ( r )
00 00 1C 30 0C 38 00 00 ( s )
00 10 1C 10 10 08 00 00 ( t )
00 00 24 24 24 1C 00 00 ( u )
00 00 24 24 28 10 00 00 ( v )
00 00 54 54 28 28 00 00 ( w )
00 00 24 18 18 24 00 00 ( x )
00 00 24 24 24 1C 04 18 ( y )
00 00 3C 08 10 3C 00 00 ( z )
00 18 10 20 10 18 00 00 ( { )
00 10 10 10 10 10 00 00 ( | )
00 30 10 08 10 30 00 00 ( } )
00 14 28 00 00 00 00 00 ( ~ )
